# WordPress Plugin Development Cursor Rules

You are an expert WordPress plugin developer. Follow these rules when developing WordPress plugins.

## Core Principles

1. **Single Responsibility**: Each plugin should have one clear purpose
2. **WordPress APIs**: Use built-in WordPress APIs (Settings, Options, Transients, HTTP, etc.)
3. **Hooks Over Modifications**: Never modify WordPress core, always use hooks
4. **Security First**: Validate, sanitize, escape, check permissions
5. **Performance**: Optimize queries, use caching, load conditionally
6. **Namespace Everything**: Use unique prefixes to avoid conflicts

## Plugin Structure

Required main plugin file with header:
```php
/**
 * Plugin Name: My Plugin Name
 * Plugin URI: https://example.com
 * Description: Brief description
 * Version: 1.0.0
 * Requires at least: 6.0
 * Requires PHP: 7.4
 * Author: Your Name
 * Author URI: https://example.com
 * License: GPL v2 or later
 * Text Domain: my-plugin
 * Domain Path: /languages
 */
```

## File Organization

```
plugin-name/
├── plugin-name.php (main file)
├── uninstall.php (cleanup)
├── includes/ (classes and functions)
├── admin/ (admin functionality)
├── public/ (public-facing functionality)
└── languages/ (translation files)
```

## Security Requirements

### Always:
- Sanitize ALL input: sanitize_text_field(), sanitize_email(), etc.
- Escape ALL output: esc_html(), esc_url(), esc_attr()
- Use nonces for forms: wp_nonce_field(), wp_verify_nonce()
- Check capabilities: current_user_can()
- Prepare database queries: $wpdb->prepare()

### Never:
- Trust user input
- Use $_GET, $_POST directly without sanitization
- Skip capability checks
- Use global namespace without prefix
- Modify WordPress core files

## Database Operations

- Use $wpdb->prepare() for all queries with variables
- Use WordPress functions when available (get_posts, get_users, etc.)
- Create custom tables in activation hook with dbDelta()
- Use proper data formats: %s (string), %d (integer), %f (float)

## Hooks and Filters

- Use add_action() for actions
- Use add_filter() for filters
- Create custom hooks for extensibility: do_action(), apply_filters()
- Use proper priority (default 10)
- Document available hooks for other developers

## Activation/Deactivation/Uninstall

### Activation (register_activation_hook):
- Create database tables
- Set default options
- Flush rewrite rules if needed
- Check PHP/WordPress version requirements

### Deactivation (register_deactivation_hook):
- Clear scheduled events
- Flush rewrite rules
- DO NOT delete data

### Uninstall (uninstall.php):
- Delete options and transients
- Drop custom tables
- Delete post meta, user meta
- Clean up completely

## Settings API

Use WordPress Settings API for admin settings:
- register_setting()
- add_settings_section()
- add_settings_field()
- Implement sanitization callbacks
- Use settings_errors() for feedback

## Admin Interface

- Use add_menu_page() or add_submenu_page()
- Check current_user_can('manage_options')
- Use WordPress admin UI components
- Enqueue admin scripts/styles only on plugin pages
- Provide clear instructions and help text

## AJAX Handling

- Use wp_ajax_{action} and wp_ajax_nopriv_{action} hooks
- Verify nonces: check_ajax_referer()
- Check capabilities
- Return JSON: wp_send_json_success(), wp_send_json_error()
- Handle errors gracefully

## Shortcodes

- Use add_shortcode() to register
- Use shortcode_atts() for attributes
- Sanitize all attributes
- Return content, don't echo (unless buffering)
- Make it clear and well-documented

## Custom Post Types

- Register with register_post_type()
- Use proper labels array
- Set show_in_rest => true for Gutenberg
- Define capabilities properly
- Flush rewrite rules on activation

## REST API

- Use register_rest_route() for custom endpoints
- Implement permission_callback for security
- Validate and sanitize all parameters
- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Return appropriate status codes

## Internationalization

- Make all strings translatable
- Use __(), _e(), esc_html__(), esc_html_e()
- Load text domain with load_plugin_textdomain()
- Include .pot file in /languages/

## Asset Loading

- Use wp_enqueue_script() and wp_enqueue_style()
- Load conditionally (only where needed)
- Use wp_localize_script() for AJAX data
- Version assets for cache busting
- Load scripts in footer when possible

## Error Handling

- Check for errors after database operations
- Use WP_Error for error returns
- Log errors for debugging (error_log)
- Provide user-friendly error messages
- Don't expose sensitive information in errors

## Performance

- Use transients for expensive operations
- Cache API responses
- Minimize database queries
- Use object caching when available
- Load assets conditionally
- Optimize queries with proper indexes

## Code Quality

- Follow WordPress Coding Standards (WPCS)
- Use meaningful variable and function names
- Add comments for complex logic
- Keep functions small and focused
- Use classes for complex functionality
- Document public APIs

## Testing

- Test with Query Monitor plugin
- Test on multiple PHP versions
- Test with WordPress debug mode enabled
- Test activation/deactivation/uninstall
- Test with various user roles

## Compatibility

- Check if functions/classes exist before defining
- Don't assume other plugins are active
- Provide graceful degradation
- Test with common plugins (WooCommerce, ACF, etc.)
- Maintain backward compatibility

## DO NOT

- Don't modify WordPress core
- Don't use deprecated functions
- Don't use extract()
- Don't trust user input
- Don't hardcode values (make configurable)
- Don't load assets everywhere
- Don't delete data on deactivation
- Don't use global namespace

## Documentation

- Document all public functions with PHPDoc
- Provide README.txt for WordPress.org
- Include usage examples
- List requirements clearly
- Document hooks for extensibility

When generating code, always prioritize security, performance, and WordPress best practices. Every function must include proper security checks and data validation.

